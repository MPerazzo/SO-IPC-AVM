
To run the project succesfully:
1- First run the daemon.
2- Secondly, the data-base.
3- Then the main server.
4- Finally, the client.

Some pieces of code were inspired from:

*Semaphores:
http://cgi.di.uoa.gr/~ad/k22/k22-lab-notes4.pdf

*SharedMemory:
http://stackoverflow.com/questions/7237540/how-to-use-shared-memory-to-communicate-between-two-processes

Marshalling modified using memcpy from data struct to datagram and viceversa, considering the following:
1- The structure doesnt contain pointers, as the memory adresses are relative to the client or server.
2- Client and server are executed from CPUÂ´s of same arquitecture.
3- Packing flag on structures is set to 0.

Logging Deamon implementation assigns same queue values to all the servers, so to know from which server the message is, a field containing the pid was added to the message struct.

Implementation of threading on serverThreading.c works up to 10 sessions, as the max length of the vector of threads was defined to be 10.

SharedMemory implementation of Daemon works with both server with fork and server with threads. Same applies to messageQueues.

Queue implementation in daemon is bidirectional, sharedMemory implementation in daemon is unidirectional. Both satisfies the obligatory requirement of being unidirectional, which is explained in the TPE.
