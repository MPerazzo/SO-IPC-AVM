*Some pieces of code were inspired from:

Named pipes:
http://codingfreak.blogspot.com/2008/09/client-server-example-with-pipes.html

Semaphores:
http://cgi.di.uoa.gr/~ad/k22/k22-lab-notes4.pdf

SharedMemory:
http://stackoverflow.com/questions/7237540/how-to-use-shared-memory-to-communicate-between-two-processes

*Marshalling modified using memcpy from data struct to datagram and viceversa, considering the following:
1- The structure doesnt contain pointers, as the memory adresses are relative to the client or server.
2- Client and server are executed from CPUÂ´s of same arquitecture.
3- Packing flag on structures is set to 0.

*Logging Deamon implementation assigns same queue values to all the servers, so to know from which server the message is, a field containing the pid was added to the message struct.

*Implementation of threading on serverThreading.c works up to 10 sessions, as the max length of the vector of threads was defined to be 10.

*SharedMemory implementation of Daemon only works with fork (server.c), as the semaphore was created to syncronize processes, not threads. This means that this implementation of Daemon will not work properly if compiled with serverThread. Use message queues comms when compiling serverThread.

*Queue implementation in daemon is bidirectional, sharedMemory implementation in daemon is unidirectional. Both satisfies the obligatory requirement of being unidirectional, which is explained in the TPE.
